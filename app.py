"""
Streamlit web application for simulating political agent reactions.

This application allows users to input text (e.g., a political speech) and
visualizes simulated reactions from a fictional voter base. It includes
features for filtering voters by demographics and party affiliation,
and displays voter reactions generated by a language model.
The sidebar shows a visual representation of the filtered voter segment.
"""
import streamlit as st
from src.profiles import load_voters, generate_reaction # Core data loading and AI model interaction
import pandas as pd
import random
import math

st.set_page_config(page_title="Political Agents", layout="wide")

# --- Custom Exceptions ---
# Define custom exceptions for specific error conditions.
class VoterDataNotFoundError(Exception):
    """Custom exception raised when the voter data file is not found."""
    """Custom exception raised when essential columns are missing from voter data."""
    pass

# --- Party Constants ---
# Define constants for party names to ensure consistency and avoid typos.
DEMOCRAT = "Democrat"
REPUBLICAN = "Republican"
INDEPENDENT = "Independent"
UNKNOWN_PARTY = "Unknown" # Represents voters with unclassified or other party affiliations.

# --- Define Party Colors ---
# Colors used for visualizing different political parties in charts and dot grids.
PARTY_COLORS = {
    DEMOCRAT: "#007bff",    # Blue for Democrats
    REPUBLICAN: "#dc3545",  # Red for Republicans
    INDEPENDENT: "#6c757d", # Grey for Independents
}
DEFAULT_PARTY_COLOR = "#adb5bd" # Default color for parties not explicitly defined or for UNKNOWN_PARTY.


# --- Visualization Helper Sub-functions ---
def _prepare_viz_data(df, grid_size=100):
    """
    Prepares data for the party distribution visualization.

    This function processes the input DataFrame to count party affiliations,
    map them to standardized party constants, and calculate the number of
    dots to display for each party in a grid visualization based on the
    Largest Remainder Method for proportional scaling.

    Args:
        df (pd.DataFrame): DataFrame containing voter data, expected to have
                           a 'party_id' column.
        grid_size (int): The total number of dots to display in the visualization grid.

    Returns:
        dict: A dictionary containing data structures for HTML generation:
            - "counts" (pd.Series): Value counts of displayable parties.
            - "total_filtered" (int): Total number of voters in the filtered DataFrame.
            - "dots_data" (dict): Dictionary mapping party names to the number of dots
                                   they should receive in the visualization.
            - "actual_dots_shown" (int): Total number of dots that will be shown (can be
                                         less than grid_size if total_filtered is small).
            - "dot_order" (list): List of party names defining the order of display.
    """
    party_col = 'party_id' # Source column for party information
    df_copy = df.copy() # Work on a copy to avoid modifying the original DataFrame

    # Map raw party data to standardized display constants (e.g., "Democratic Party" -> DEMOCRAT)
    party_mapping = {
        'Democratic Party': DEMOCRAT,
        'Republican Party': REPUBLICAN,
        # Other specific party names from data can be mapped here
    }
    df_copy['display_party'] = df_copy[party_col].map(party_mapping).fillna(UNKNOWN_PARTY)

    # Consolidate less common or unmapped parties into INDEPENDENT for visualization simplicity
    main_parties_for_display = [DEMOCRAT, REPUBLICAN, INDEPENDENT]
    df_copy['display_party'] = df_copy['display_party'].apply(
        lambda x: x if x in main_parties_for_display else INDEPENDENT
    )
    counts = df_copy['display_party'].value_counts() # Count occurrences of each display party
    total_filtered = len(df_copy) # Total number of voters in the current filtered set

    dots_data = {} # Stores the number of dots per party
    dot_order = [DEMOCRAT, REPUBLICAN, INDEPENDENT] # Defines the consistent order for display

    # Determine how many dots each party gets
    if total_filtered == 0:
        actual_dots_shown = 0
        for party in dot_order:
            dots_data[party] = 0 # No voters, so zero dots for all parties
    elif total_filtered <= grid_size:
        # If total voters are fewer than or equal to grid size, show one dot per voter
        for party in dot_order:
            dots_data[party] = counts.get(party, 0)
        actual_dots_shown = total_filtered
    else:
        # If total voters exceed grid size, scale dots proportionally using Largest Remainder Method
        actual_dots_shown = grid_size
        for party in dot_order: # Initialize with 0 dots
            dots_data[party] = 0

        if total_filtered > 0: # Proceed only if there are voters to represent
            # Calculate ideal dots (float) for each party's proportion
            ideal_dots_float = {
                party: (counts.get(party, 0) / total_filtered) * grid_size
                for party in dot_order
            }

            # Assign the integer part of ideal dots to each party
            for party in dot_order:
                dots_data[party] = int(ideal_dots_float[party])

            # Calculate the sum of these initial integer dots
            current_total_dots = sum(dots_data.values())

            # Determine how many dots are remaining to be distributed
            dots_to_distribute = grid_size - current_total_dots

            # Calculate the fractional remainders for each party
            remainders = {
                party: ideal_dots_float[party] - dots_data[party]
                for party in dot_order
            }

            # Sort parties by their remainders in descending order to prioritize
            # those "most deserving" of the next dot.
            # Tie-breaking: If remainders are equal, prioritize party with larger original count.
            sorted_parties_by_remainder = sorted(
                dot_order,
                key=lambda p: (remainders[p], counts.get(p, 0)), # Primary sort by remainder, secondary by original count
                reverse=True
            )

            # Distribute the remaining dots one by one to parties with the largest remainders
            for i in range(dots_to_distribute):
                party_to_get_dot = sorted_parties_by_remainder[i % len(sorted_parties_by_remainder)]
                dots_data[party_to_get_dot] += 1
        # If total_filtered is 0 (e.g., due to extreme filtering leading to no matching display_party types),
        # all parties will have 0 dots, which is already handled by initialization.

    return {
        "counts": counts,
        "total_filtered": total_filtered,
        "dots_data": dots_data,
        "actual_dots_shown": actual_dots_shown,
        "dot_order": dot_order,
    }

def _generate_viz_html(viz_data):
    """
    Generates HTML for the party distribution visualization based on prepared data.

    Args:
        viz_data (dict): A dictionary containing data from `_prepare_viz_data`,
                         including party counts, dot allocations, total voters,
                         and display order.

    Returns:
        str: An HTML string representing the dot grid visualization and labels.
    """
    counts = viz_data["counts"]
    total_filtered = viz_data["total_filtered"]
    dots_data = viz_data["dots_data"]
    actual_dots_shown = viz_data["actual_dots_shown"]
    dot_order = viz_data["dot_order"]

    # Start of the visualization container
    html = f"<div class='viz-container'>"

    # Header: Displays sample size information
    if total_filtered == 0:
         html += f"<div class='viz-header'><b>Sample Size</b> (0 voters represented):</div>"
         html += "<small>No voters match the current filters for visualization.</small>"
    else:
        html += f"<div class='viz-header'><b>Sample Size</b> ({total_filtered} voters represented in {actual_dots_shown} dots):</div>"
        html += "<div class='viz-content'>" # Content wrapper for labels and grid

        # Labels Part: Displays party names, colors, and actual counts
        labels_html = "<div class='viz-labels'>"
        for party in dot_order:
            count = counts.get(party, 0) # Actual count for the party
            color = PARTY_COLORS.get(party, DEFAULT_PARTY_COLOR)
            labels_html += f"<div class='label-item'><span class='dot-label' style='background-color: {color};'></span> {party}: {count}</div>"
        labels_html += "</div>" # End of viz-labels
        html += labels_html

        # Dot Grid Part: Displays colored dots representing party distribution
        dots_html = "<div class='dot-grid'>"
        for party in dot_order:
            num_dots_to_show = dots_data.get(party, 0) # Number of dots assigned to this party
            color = PARTY_COLORS.get(party, DEFAULT_PARTY_COLOR)
            # Create a span for each dot, styled with party color and title for tooltip
            dots_html += f'<span class="dot" style="background-color: {color};" title="{party}"></span>' * num_dots_to_show
        dots_html += "</div>" # End of dot-grid
        html += dots_html
        html += "</div>" # End of viz-content

    html += "</div>" # End of viz-container
    return html

# --- Main Helper Function for Visualization ---
def create_party_viz_html(df, grid_size=100):
    """
    Generates HTML for a party distribution dot grid visualization.

    This function serves as the primary interface for creating the visualization.
    It handles initial DataFrame emptiness check, calls helper functions to
    prepare data and generate HTML.

    Args:
        df (pd.DataFrame): DataFrame containing voter data. Expected to have
                           columns like 'party_id'.
        grid_size (int): The total number of dots to display in the grid.

    Returns:
        str: An HTML string for the visualization. If the input DataFrame `df`
             is empty, it returns a message indicating no data is available.
             If `df` is not empty but filters result in no voters for the
             visualization, a different message is shown.
    """
    # Handle case where the initial DataFrame passed to the function is completely empty.
    if df.empty:
        return "<small>No voters data available to display.</small>"

    # Prepare data using the helper function.
    viz_data = _prepare_viz_data(df, grid_size)

    # If data preparation results in zero filtered voters (e.g., filters are too restrictive),
    # _generate_viz_html will produce a message like "No voters match the current filters...".
    # This is distinct from the initial df.empty check.
    return _generate_viz_html(viz_data)


# --- Custom Styles ---
# Defines CSS styles for various UI elements like title, voter cards, and visualization.
# Using st.markdown with unsafe_allow_html=True to apply custom CSS.
st.markdown("""
    <style>
        /* --- General Header Styles --- */
        .title { font-size: 2.5em; font-weight: 700; margin-bottom: 0.1em; color: #333; }
        .subtitle { font-size: 1.2em; color: #555; margin-bottom: 1.5em; }

        /* --- Voter Card Styles --- */
        .voter-card {
            border: 1px solid #e0e0e0;
            padding: 1.2em;
            border-radius: 8px;
            background-color: #ffffff;
            margin-bottom: 1.5em;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            line-height: 1.6;
        }
        .voter-card:hover {
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            border-color: #cccccc;
        }
        .voter-info {
            font-size: 0.95em;
            color: #333;
            margin-bottom: 0.8em;
        }
        .voter-name {
            font-weight: 600;
            font-size: 1.1em;
            color: #000;
        }
        .voter-details {
            font-size: 0.85em;
            color: #666;
            margin-bottom: 1em;
        }
        .reaction-header {
            font-weight: 600;
            font-size: 1em;
            color: #111;
            margin-bottom: 0.3em;
        }

        /* --- Dot Visualization Styles --- */
        .viz-container {
            margin-top: 1em; padding: 0.8em; border: 1px solid #eee;
            border-radius: 4px; background-color: #f8f9fa;
        }
        .viz-header { font-size: 0.9em; margin-bottom: 8px; }
        .viz-content { /* No longer using flex here */ }
        .viz-labels {
             /* Removed margin-right, flex-shrink */
             margin-bottom: 10px; /* Add space between labels and grid */
        }
        .label-item { font-size: 0.85em; margin-bottom: 3px; white-space: nowrap; }
        .dot-label {
            display: inline-block; width: 10px; height: 10px;
            border-radius: 3px; margin-right: 5px; vertical-align: middle;
        }
        .dot-grid {
            display: grid;
            grid-template-columns: repeat(10, 9px); /* 10 columns */
            gap: 2px;
            line-height: 0;
            width: fit-content; /* Make grid only as wide as needed */
            margin-left: auto;  /* Center the grid horizontally */
            margin-right: auto; /* Center the grid horizontally */
        }
        .dot {
            display: inline-block; width: 9px; height: 9px;
            border-radius: 50%; vertical-align: middle;
        }
    </style>
""", unsafe_allow_html=True)

# --- Application Title and Subtitle ---
st.markdown('<div class="title">Political Agents</div>', unsafe_allow_html=True)
st.markdown('<div class="subtitle">Fictional voter reactions based on survey profiles. Enter text below.</div>', unsafe_allow_html=True)

# --- Data Loading and Caching ---
@st.cache_data # Cache the loaded data to improve performance on reruns.
def cached_load_voters():
    """
    Loads voter data using src.profiles.load_voters and handles potential errors.

    This function serves as a cached wrapper around the main data loading
    functionality. It translates FileNotFoundError to VoterDataNotFoundError
    and ensures that MissingColumnsError (raised by load_voters) is propagated.

    Raises:
        VoterDataNotFoundError: If the voter data file ('sample_voter_file.csv')
                                is not found or if the loaded data is empty.
        MissingColumnsError: Propagated from `load_voters` if essential columns
                             are missing in the data file.

    Returns:
        pd.DataFrame: A DataFrame containing the voter data. Returns an empty
                      DataFrame if an error occurs that's handled by returning empty,
                      though most errors will raise exceptions.
    """
    try:
        df = load_voters() # Calls the function from src.profiles
        if df is None or df.empty: # Check if data loading itself returned empty/None
             raise VoterDataNotFoundError("Voter data could not be loaded or is empty.")
        return df
    except FileNotFoundError:
        # Specific handling for file not found, re-raising as a custom app-level exception.
        raise VoterDataNotFoundError("Error: 'sample_voter_file.csv' not found. Please ensure it's in the correct directory.")
    # MissingColumnsError from load_voters() will be caught by the caller of cached_load_voters().

# Main data loading block with error handling.
try:
    voters_df = cached_load_voters()
except VoterDataNotFoundError as e:
    st.error(str(e)) # Display error message to the user.
    st.stop() # Halt execution if data isn't found.
except MissingColumnsError as e:
    st.error(str(e)) # Display error for missing columns.
    st.stop() # Halt execution.
except Exception as e: # Catch any other unexpected errors during data loading.
    st.error(f"An unexpected error occurred while loading data: {e}")
    st.stop()

# Fallback check, though exceptions should ideally cover all failure modes.
if voters_df.empty:
    st.error("Failed to load voter data. The application cannot continue.")
    st.stop()


# --- Sidebar: Voter Filters ---
# Filters for party ID and ideology are placed in the sidebar.
with st.sidebar:
    st.header("Filter Voters")

    # Create filter options dynamically from the loaded data.
    # 'All' option allows users to see data without filtering by that category.
    party_options = ["All"] + sorted(voters_df["party_id"].dropna().unique())
    selected_party = st.selectbox(
        "Party ID", party_options, help="Filter voters by their political party affiliation."
    )

    ideology_options = ["All"] + sorted(voters_df["ideology"].dropna().unique())
    selected_ideology = st.selectbox(
        "Ideology", ideology_options, help="Filter voters by their political ideology."
    )

    # Apply filters to the DataFrame.
    # Start with a copy of the full DataFrame and narrow it down based on selections.
    filtered_df = voters_df.copy()
    if selected_party != "All":
        filtered_df = filtered_df[filtered_df["party_id"] == selected_party]
    if selected_ideology != "All":
        filtered_df = filtered_df[filtered_df["ideology"] == selected_ideology]

    # Display the party distribution visualization in the sidebar for the filtered data.
    st.divider() # Visual separator.
    viz_html = create_party_viz_html(filtered_df, grid_size=100)
    st.markdown(viz_html, unsafe_allow_html=True)


# --- Main Area: Input for Speech/Text and Reaction Generation ---
speech = st.text_area(
    "Paste your content below:",
    height=200,
    placeholder="Enter a political speech, news article excerpt, or statement..."
)
generate = st.button("Generate Reactions") # Button to trigger reaction generation.
st.divider() # Visual separator.

# Display simulated reactions when the button is pressed and speech input is provided.
if speech and generate:
    if 'filtered_df' not in locals() or filtered_df.empty:
        # Check if filtered_df exists and is not empty.
        # 'filtered_df' might not exist if sidebar filters somehow failed,
        # though this is unlikely with current structure.
        st.warning("No voters match the selected filters or data is unavailable. Please broaden your criteria or check data source.")
    else:
        # Determine sample size for reactions: min of 3 or available filtered voters.
        sample_size = min(3, len(filtered_df))
        # Randomly sample voters from the filtered list.
        sampled_voters = filtered_df.sample(n=sample_size)

        st.subheader(f"Simulated Reactions from {sample_size} Voters:")

        # Generate and display reactions for each sampled voter.
        with st.spinner("Simulating voter reactions... this may take a moment."): # Show loading spinner.
            for _, row in sampled_voters.iterrows():
                try:
                    # Call the AI model to generate a reaction for the current voter.
                    reaction = generate_reaction(speech, row)
                except Exception as e:
                    # Fallback error message if reaction generation fails for a specific voter.
                    st.error(f"Could not generate reaction for {row.get('name', 'Unknown Voter')}: {e}")
                    reaction = "Error generating reaction."

                # Display voter information and their simulated reaction in a styled card.
                # Using f-string for multiline HTML content.
                # .get(column, 'N/A') is used for safe access to DataFrame row data.
                card_content = f"""
                <div class="voter-card">
                    <div class="voter-name">{row.get('name', 'N/A')}</div>
                    <div class="voter-info">
                        {row.get('age_group', 'N/A')} | {row.get('ideology', 'N/A')} | {row.get('party_id', 'N/A')}
                    </div>
                    <div class="voter-details">
                        District: {row.get('congressional_district', 'N/A')} | Education: {row.get('education_expanded', 'N/A')} | Race: {row.get('race_expanded', 'N/A')} | Income: {row.get('income', 'N/A')}
                    </div>
                    <div class="reaction-header">Reaction:</div>
                    {reaction}
                </div>
                """
                st.markdown(card_content, unsafe_allow_html=True)
